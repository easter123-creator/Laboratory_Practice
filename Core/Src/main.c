#include <stdint.h>
#include "init.h"


// страна где находятся регионы - память
// регион - то где находятся города
// перифирия - город
// регистр - улица
// бит - дом

// UL - unsigned long беззнаковый длинный тип

/*

*(uint32_t*)(0x40023800UL+0x30UL) |= 0x06UL; таким образом работаем напрямую с нужной ячейкой памяти

0x40023800UL - адрес нужной периферии  (RCC)

+0x30UL - адрес нужного регистра (RCC_AHB1ENR)

(uint32_t*) - приведение результата к указателю на 32-битное значение (регистры у STM32 32-битные)

*() - разыменование указателя, чтобы обратиться к самому регистру(его содержимому)

|= 0x06UL - побитовое ИЛИ с числом 0x06 (то есть установка битов 1 и 2) у текущего значения регистра

|= 0x06UL - включает тактирование портов GPIOB и GPIOC, так как биты 1 и 2 отвечают за эти порты

0x06 = 0000 0000 0000 0000 0000 0000 0000 0110

тактирование - процесс подачи синхронизирующих тактовых импульсов от источника тактового сигнала ко всем
внутренним блокам микроконтроллера (ядру, шинам данных, периферийным устройствам и т.д.) для их синхронизации и работы

Таким образом, включая тактирование у конкретного порта GPIO, например, через запись в регистр RCC_AHB1ENR, как в коде,
вы разрешаете подачу тактового сигнала этому блоку, что позволяет ему работать

Включая тактирование для конкретного блока микроконтроллера (например, GPIO порта), вы как бы говорите системе,
что хотите с ним работать и разрешаете подачу тактового сигнала этому периферийному модулю.




GPIOB->MODER &= ~(0b11 << (7 * 2));  // Сбросить оба бита режима пина 7
GPIOB->MODER |=  (0b01 << (7 * 2));  // Установить режим "вывод" для пина 7

(0b11 << (7 * 2)) означает сдвинуть двоичное число 0b11 (то есть двоичное 11) на 14 бит влево


GPIOB->MODER &= ~(0b11 << (7 * 2));

запись (0b11 << (7 * 2)) эквивалентна 0000 0000 0000 0000 1100 0000 0000 0000

~ инвертирует это и получится 1111 1111 1111 1111 0011 1111 1111 1111

потом умножаем конфигурацию битов которая сейчас есть на это &=

и в итоге получим что 14 и 15 биты скинутся в ноль, а все остальные биты останутся без изменений

*/
int main(void){
    *(uint32_t*)(0x40023800UL+0x30UL) |= 0x06UL; //Включение тактирования порта GPIOB

    *(uint32_t*)(0x40020400UL+0x00UL) |= 0x4000UL; //Настройка работы 7-го пина GPIOB в режиме вывода сигнала
    *(uint32_t*)(0x40020400UL+0x04UL) |= 0x00UL; //Настройка на PushPull работу 7-го пина GPIOB
    *(uint32_t*)(0x40020400UL+0x08UL) |= 0x4000UL; //Настройка скорости работы 7-го пина GPIOB на среднюю
    *(uint32_t*)(0x40020400UL+0x18UL) |= 0x800000UL; //Отключение PU/PD резисторов для 7-го пина GPIOB
    // Кнопку подключаем к PC13 или к PC12 если кнопка сломана
    while(1)
    {
        if (*(uint32_t*)(0x40020800UL + 0x10UL) & 0x2000UL)
        {
            *(uint32_t*)(0x40020400UL+0x18UL) |= 0x80UL;
        }
        else
        {
            *(uint32_t*)(0x40020400UL+0x18UL) |= 0x800000UL;
        }
    }
}
int main(void)
{
     GPIO_init_7_pin ();
     GPIO_init_14_pin ();
    while (1) //
    {
        if (BIT_READ(GPIOC_IDR, GPIO_PIN_13)) // опереатор if, в котором логически умножается IDR на значение
        {
            BIT_SET(GPIOB_BSRR, GPIO_PIN_SET_7);    //Синий светодиод
            BIT_SET(GPIOB_BSRR, GPIO_PIN_RESET_14);   // Включает светодиод BSSR, если нажата кнопка
        }
        else
        {
            BIT_SET(GPIOB_BSRR, GPIO_PIN_SET_14);
            BIT_SET(GPIOB_BSRR, GPIO_PIN_RESET_7);
        }
    }
}